from datetime import datetime, timezone, timedelta
import requests
from flask import Flask, render_template, request, session, redirect, url_for, send_from_directory, Response
import os
import sqlite3
import io
import csv
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from dotenv import load_dotenv

load_dotenv()
app = Flask(__name__)
app.secret_key = 'babatunde_map_intelligence_2025'

API_KEY = os.getenv('WEATHER_API_KEY')

# --- DATABASE SETUP ---


def init_db():
    conn = sqlite3.connect('final_weather.db')
    conn.execute(
        'CREATE TABLE IF NOT EXISTS history (city TEXT, temp REAL, timestamp DATETIME)')
    conn.close()


def save_search(city, temp):
    conn = sqlite3.connect('final_weather.db')
    conn.execute('INSERT INTO history (city, temp, timestamp) VALUES (?, ?, ?)',
                 (city, temp, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    conn.commit()
    conn.close()


def get_history():
    conn = sqlite3.connect('final_weather.db')
    cursor = conn.execute(
        'SELECT city, temp FROM history ORDER BY timestamp DESC LIMIT 5')
    rows = cursor.fetchall()
    conn.close()
    return rows


init_db()

# --- PDF GENERATION ROUTE ---


@app.route('/download_pdf')
def download_pdf():
    # Retrieve current results from session
    weather_list = session.get('last_results', [])
    if not weather_list:
        return redirect(url_for('index'))

    buffer = io.BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Header
    p.setFont("Helvetica-Bold", 20)
    p.drawCentredString(width/2, height - 50,
                        "GEOSPATIAL WEATHER INTELLIGENCE REPORT")

    p.setFont("Helvetica", 10)
    p.drawCentredString(
        width/2, height - 70, f"Generated by: Babatunde Abass | {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    p.line(50, height - 80, width - 50, height - 80)

    # Body Content
    y_position = height - 120
    for w in weather_list:
        if y_position < 100:
            p.showPage()
            y_position = height - 50

        p.setFont("Helvetica-Bold", 14)
        p.drawString(70, y_position, f"Location: {w['city']}")

        p.setFont("Helvetica", 12)
        p.drawString(90, y_position - 20, f"Temperature: {w['temp']}Â°C")
        p.drawString(90, y_position - 35,
                     f"Conditions: {w['desc'].capitalize()}")
        p.drawString(90, y_position - 50, f"Local Time: {w['local_time']}")
        p.drawString(90, y_position - 65,
                     f"Coordinates: {w['lat']}, {w['lon']}")

        y_position -= 100

    p.showPage()
    p.save()
    buffer.seek(0)

    return Response(buffer, mimetype='application/pdf',
                    headers={"Content-Disposition": "attachment; filename=Weather_Analysis_Report.pdf"})


@app.route('/export')
def export_data():
    conn = sqlite3.connect('final_weather.db')
    cursor = conn.execute('SELECT * FROM history')
    results = cursor.fetchall()
    si = io.StringIO()
    cw = csv.writer(si)
    cw.writerow(['City', 'Temperature', 'Timestamp'])
    cw.writerows(results)
    return Response(si.getvalue(), mimetype="text/csv",
                    headers={"Content-Disposition": "attachment; filename=weather_history.csv"})


@app.route('/', methods=['GET', 'POST'])
def index():
    weather_list = []
    stats = {}
    report_date = datetime.now().strftime("%B %d, %Y | %H:%M")

    if request.method == 'POST':
        city_input = request.form.get('city', '')
        cities = [c.strip() for c in city_input.split(',') if c.strip()]

        for city in cities:
            url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&units=metric&appid={API_KEY}"
            try:
                response = requests.get(url).json()
                if response.get('cod') == 200:
                    temp = round(response['main']['temp'], 1)
                    utc_now = datetime.now(timezone.utc)
                    offset_seconds = int(response.get('timezone', 0))
                    local_dt = utc_now + timedelta(seconds=offset_seconds)

                    weather_data = {
                        'city': response['name'],
                        'temp': temp,
                        'humidity': response['main']['humidity'],
                        'desc': response['weather'][0]['description'],
                        'icon': response['weather'][0]['icon'],
                        'lat': response['coord']['lat'],
                        'lon': response['coord']['lon'],
                        'local_time': local_dt.strftime("%I:%M %p")
                    }
                    weather_list.append(weather_data)
                    save_search(response['name'], temp)
            except Exception as e:
                print(f"Error: {e}")

        if weather_list:
            stats['hottest'] = max(
                weather_list, key=lambda x: x['temp'])['city']
            stats['coldest'] = min(
                weather_list, key=lambda x: x['temp'])['city']
            stats['avg_temp'] = round(
                sum(d['temp'] for d in weather_list) / len(weather_list), 1)
            # Store in session for the PDF generator
            session['last_results'] = weather_list

    recent_history = get_history()
    return render_template('index.html', weather_list=weather_list, report_date=report_date, stats=stats, history=recent_history)


@app.route('/clear')
def clear_session():
    session.clear()
    return redirect(url_for('index'))


if __name__ == '__main__':
    app.run(debug=True)
